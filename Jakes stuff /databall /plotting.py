{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "d7d07679-e747-4ddb-ba7d-193b889ece19",
   "metadata": {},
   "outputs": [],
   "source": [
    "from itertools import product\n",
    "\n",
    "import matplotlib.pyplot as plt\n",
    "import numpy as np\n",
    "import seaborn as sns\n",
    "from sklearn.metrics import (\n",
    "    average_precision_score,\n",
    "    precision_recall_curve,\n",
    "    roc_auc_score,\n",
    "    roc_curve,\n",
    ")\n",
    "from sklearn.model_selection import StratifiedKFold, cross_val_predict\n",
    "\n",
    "\n",
    "def cross_val_curves(model, x, y, k=10, figsize=(16, 6), legend=True):\n",
    "    fig = plt.figure(figsize=figsize)\n",
    "\n",
    "    # Plot ROC curve\n",
    "    ax1 = plt.subplot(121)\n",
    "    cross_val_roc_curve(model, x, y, ax1, k=k, label='Mean', show_folds=True)\n",
    "\n",
    "    # Plot precision/recall curve\n",
    "    ax2 = plt.subplot(122)\n",
    "    cross_val_precision_recall_curve(model, x, y, ax2, k=k, label='Mean', show_folds=True)\n",
    "\n",
    "    if legend:\n",
    "        ax1.legend()\n",
    "        ax2.legend()\n",
    "\n",
    "    return fig, ax1, ax2\n",
    "\n",
    "\n",
    "def cross_val_precision_recall_curve(model, x, y, ax, k=10, random_state=8, label='Mean',\n",
    "                                     show_auc=True, show_folds=False):\n",
    "    # Compute cross-validated precision/recall curve and area under the curve\n",
    "    kfold = StratifiedKFold(n_splits=k, random_state=random_state)\n",
    "    proba = cross_val_predict(model, x, y, cv=kfold, method='predict_proba')\n",
    "    mean_precision, mean_recall, thresholds = precision_recall_curve(y, proba[:, 1])\n",
    "    mean_auc = average_precision_score(y, proba[:, 1])\n",
    "\n",
    "    # Loop over k folds and get precision/recall curve for each fold\n",
    "    if show_folds:\n",
    "        for i, (train, test) in enumerate(kfold.split(x, y)):\n",
    "            # Fit model for the ith fold\n",
    "            proba = model.fit(x.iloc[train], y[train]).predict_proba(x.iloc[test])\n",
    "\n",
    "            # Compute precision/recall curve and area under the curve\n",
    "            precision, recall, thresholds = precision_recall_curve(y[test], proba[:, 1])\n",
    "            pr_auc = average_precision_score(y[test], proba[:, 1])\n",
    "            ax.plot(recall, precision, lw=1, label='Fold %d (Area = %0.2f)' % (i + 1, pr_auc))\n",
    "\n",
    "        ax.plot(mean_recall, mean_precision, 'k--', label=f'{label} (Area = {mean_auc:0.2f})', lw=2)\n",
    "    elif show_auc:\n",
    "        ax.plot(mean_recall, mean_precision, label=f'{label} (Area = {mean_auc:0.2f})', lw=2)\n",
    "    else:\n",
    "        ax.plot(mean_recall, mean_precision, label=label, lw=2)\n",
    "\n",
    "    ax.set_xlabel('Recall')\n",
    "    ax.set_ylabel('Precision')\n",
    "\n",
    "\n",
    "def cross_val_roc_curve(model, x, y, ax, k=10, random_state=8, label='Mean', show_auc=True, show_folds=False):\n",
    "    # Compute cross-validated ROC curve and area under the curve\n",
    "    kfold = StratifiedKFold(n_splits=k, random_state=random_state)\n",
    "    proba = cross_val_predict(model, x, y, cv=kfold, method='predict_proba')\n",
    "    mean_fpr, mean_tpr, thresholds = roc_curve(y, proba[:, 1])\n",
    "    mean_auc = roc_auc_score(y, proba[:, 1])\n",
    "\n",
    "    # Loop over k folds and get ROC curve for each fold\n",
    "    if show_folds:\n",
    "        for i, (train, test) in enumerate(kfold.split(x, y)):\n",
    "            # Fit model for the ith fold\n",
    "            proba = model.fit(x.iloc[train], y[train]).predict_proba(x.iloc[test])\n",
    "\n",
    "            # Compute ROC curve and area under the curve\n",
    "            fpr, tpr, thresholds = roc_curve(y[test], proba[:, 1])\n",
    "            roc_auc = roc_auc_score(y[test], proba[:, 1])\n",
    "            ax.plot(fpr, tpr, lw=1, label='Fold %d (Area = %0.2f)' % (i + 1, roc_auc))\n",
    "\n",
    "        ax.plot(mean_fpr, mean_tpr, 'k--', label=f'{label} (Area = {mean_auc:0.2f})', lw=2)\n",
    "    elif show_auc:\n",
    "        ax.plot(mean_fpr, mean_tpr, label=f'{label} (Area = {mean_auc:0.2f})', lw=2)\n",
    "    else:\n",
    "        ax.plot(mean_fpr, mean_tpr, label=label, lw=2)\n",
    "\n",
    "    ax.set_xlabel('False Positive Rate')\n",
    "    ax.set_ylabel('True Positive Rate')\n",
    "\n",
    "\n",
    "def format_538(fig, source, ax=None, xlabel=None, ylabel=None, title=None, subtitle=None, bottomtick=0, sig='line',\n",
    "               n=75, xoff=(-0.075, 1.01), yoff=(-0.1, -0.15), toff=(-0.07, 1.15), soff=(-0.07, 1.05),\n",
    "               prefix='', suffix='', suffix_offset=0):\n",
    "    plt.style.use('fivethirtyeight')\n",
    "\n",
    "    if ax is None:\n",
    "        ax = [fig.gca()]\n",
    "    elif type(ax) is not list and type(ax) is not tuple:\n",
    "        ax = [ax]\n",
    "\n",
    "    if type(bottomtick) is not list and type(bottomtick) is not tuple:\n",
    "        bottomtick = [bottomtick] * len(ax)\n",
    "\n",
    "    # Customize axis labels\n",
    "    if xlabel is None:\n",
    "        [a.set_xlabel(a.get_xlabel(), fontsize=20, weight='bold') for a in ax]\n",
    "    elif type(xlabel) is str:\n",
    "        plt.xlabel(xlabel, fontsize=20, weight='bold')\n",
    "    else:\n",
    "        [a.set_xlabel(x, fontsize=20, weight='bold') for a, x in zip(ax, xlabel)]\n",
    "\n",
    "    if ylabel is None:\n",
    "        [a.set_ylabel(a.get_ylabel(), fontsize=20, weight='bold') for a in ax]\n",
    "    elif type(ylabel) is str:\n",
    "        plt.ylabel(ylabel, fontsize=20, weight='bold')\n",
    "    else:\n",
    "        [a.set_ylabel(y, fontsize=20, weight='bold') for a, y in zip(ax, ylabel)]\n",
    "\n",
    "    # Customize ticks\n",
    "    [a.tick_params(axis='both', which='major', labelsize=16) for a in ax]\n",
    "    [a.axhline(y=btick, color='black', linewidth=1.3, alpha=0.7) for a, btick in zip(ax, bottomtick)]\n",
    "    fig.canvas.draw()\n",
    "    [t.set_alpha(0.5) for a in ax for t in a.get_xticklabels()]\n",
    "    [t.set_alpha(0.5) for a in ax for t in a.get_yticklabels()]\n",
    "\n",
    "    if type(prefix) is str:\n",
    "        prefix = [prefix]\n",
    "\n",
    "    if type(suffix) is str:\n",
    "        suffix = [suffix]\n",
    "\n",
    "    if type(suffix_offset) is not list and type(suffix_offset) is not tuple:\n",
    "        suffix_offset = [suffix_offset]\n",
    "\n",
    "    for (a, p, s, so) in zip(ax, prefix, suffix, suffix_offset):\n",
    "        ticks = a.get_yticklabels()\n",
    "        index = [i for i in range(len(ticks)) if len(ticks[i].get_text()) == 0]\n",
    "\n",
    "        if len(index) > 0:\n",
    "            index = max(index) - 1\n",
    "        else:\n",
    "            index = len(ticks) - 1\n",
    "\n",
    "        [t.set_text(t.get_text() + ' ' * so) for t in ticks[:index]]\n",
    "        ticks[index].set_text(p + ticks[index].get_text() + s)\n",
    "        a.set_yticklabels(ticks)\n",
    "\n",
    "    # Add title and subtitle\n",
    "    ax[0].text(x=toff[0], y=toff[1], s=title, fontsize=26, weight='bold', alpha=0.75, transform=ax[0].transAxes)\n",
    "    ax[0].text(x=soff[0], y=soff[1], s=subtitle, fontsize=20, alpha=0.85, transform=ax[0].transAxes)\n",
    "    [a.set_title(a.get_title(), fontsize=20, weight='bold') for a in ax]\n",
    "\n",
    "    # Add signature bar\n",
    "    label1 = 'Â©Kevin Lane'\n",
    "    label2 = 'Source: ' + source\n",
    "\n",
    "    if sig == 'line':\n",
    "        ax[0].text(x=xoff[0], y=yoff[0], s='  ' + '_' * n, color='grey', alpha=0.7, transform=ax[0].transAxes)\n",
    "        ax[0].text(x=xoff[1], y=yoff[0], s='_' * n + '  ', color='grey', alpha=0.7, transform=ax[0].transAxes,\n",
    "                   horizontalalignment='right')\n",
    "        ax[0].text(x=xoff[0], y=yoff[1], s='  ' + label1, fontsize=14, color='grey', transform=ax[0].transAxes)\n",
    "        ax[0].text(x=xoff[1], y=yoff[1], s=label2 + '  ', fontsize=14, color='grey', transform=ax[0].transAxes,\n",
    "                   horizontalalignment='right')\n",
    "    elif sig == 'bar':\n",
    "        ax[0].text(x=xoff[0], y=-0.14, s='  ' + label1 + ' ' * n, fontsize=14, color='#f0f0f0', backgroundcolor='grey',\n",
    "                   transform=ax[0].transAxes)\n",
    "        ax[0].text(x=xoff[1], y=-0.14, s=' ' * n + label2 + '  ', fontsize=14, color='#f0f0f0', backgroundcolor='grey',\n",
    "                   transform=ax[0].transAxes, horizontalalignment='right')\n",
    "\n",
    "\n",
    "def kde(data, stat, label, title, ax):\n",
    "    stat = 'TEAM_' + stat\n",
    "    sns.kdeplot(data[stat], data[stat + '_AWAY'], cmap='Blues', shade=True, shade_lowest=False, ax=ax)\n",
    "    ax.plot(0, 0, 'or', markersize=10)\n",
    "    ax.set_xlabel('Home Team ' + label)\n",
    "    ax.set_ylabel('Away Team ' + label)\n",
    "    ax.set_title(title)\n",
    "    ax.set_xlim(-13, 12)\n",
    "    ax.set_ylim(-16, 12)\n",
    "    ax.annotate('Average teams', xy=(-0.25, -0.25), xytext=(-13, -13), fontsize=16, arrowprops=dict(facecolor='black'))\n",
    "\n",
    "\n",
    "def plot_confusion_matrix(cm, classes, fig=None, title='Confusion Matrix', cmap=plt.get_cmap('Blues')):\n",
    "    # This function prints and plots the confusion matrix.\n",
    "    if fig is None:\n",
    "        fig = plt.imshow(cm, interpolation='nearest', cmap=cmap)\n",
    "    else:\n",
    "        plt.imshow(cm, interpolation='nearest', cmap=cmap)\n",
    "\n",
    "    plt.title(title)\n",
    "    plt.colorbar()\n",
    "    tick_marks = np.arange(len(classes))\n",
    "    plt.xticks(tick_marks, classes, rotation=45)\n",
    "    plt.yticks(tick_marks, classes)\n",
    "    plt.grid(visible=False)\n",
    "\n",
    "    cm_norm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]\n",
    "    thresh = (cm.max() + cm.min()) / 2\n",
    "\n",
    "    for i, j in product(range(cm.shape[0]), range(cm.shape[1])):\n",
    "        plt.text(j, i, '%d\\n%.2f%%' % (cm[i, j], cm_norm[i, j] * 100),\n",
    "                 horizontalalignment='center', color='white' if cm[i, j] > thresh else 'black')\n",
    "\n",
    "    plt.tight_layout()\n",
    "    plt.ylabel('True Label')\n",
    "    plt.xlabel('Predicted Label')\n",
    "\n",
    "    return fig\n",
    "\n",
    "\n",
    "def plot_matrix(x, y, xlabel, ylabel, rows, cols, figsize=(16, 8), logx=False, logy=False, markersize=5):\n",
    "    fig = plt.figure(figsize=figsize)\n",
    "    ax = []\n",
    "    n = len(ylabel)\n",
    "\n",
    "    if type(logy) is bool:\n",
    "        logy = [logy] * n\n",
    "\n",
    "    for i in range(n):\n",
    "        ax += [plt.subplot(rows, cols, i + 1)]\n",
    "\n",
    "        if logx and logy[i]:\n",
    "            ax[i].loglog(x, y[:, i], '.', markersize=markersize)\n",
    "        elif logx:\n",
    "            ax[i].semilogx(x, y[:, i], '.', markersize=markersize)\n",
    "        elif logy[i]:\n",
    "            ax[i].semilogy(x, y[:, i], '.', markersize=markersize)\n",
    "        else:\n",
    "            ax[i].plot(x, y[:, i], '.', markersize=markersize)\n",
    "\n",
    "        ax[i].set_xlabel(xlabel)\n",
    "        ax[i].set_ylabel(ylabel[i])\n",
    "\n",
    "    return fig, ax\n",
    "\n",
    "\n",
    "def plot_metrics(x, y, xlabel, legend=None, legendsize=14, figsize=(16, 8), log=False):\n",
    "    rows = 2\n",
    "    cols = 3\n",
    "    ylabel = ['Accuracy', 'Precision', 'Recall', 'ROC Area', 'Precision/Recall Area']\n",
    "    fig = plt.figure(figsize=figsize)\n",
    "    ax = []\n",
    "\n",
    "    for i in range(len(ylabel)):\n",
    "        ax += [plt.subplot(100 * rows + 10 * cols + i + 1)]\n",
    "\n",
    "        if log:\n",
    "            [ax[i].semilogx(x, [yvec[i] for yvec in y[j]]) for j in range(len(y))]\n",
    "        else:\n",
    "            [ax[i].plot(x, [yvec[i] for yvec in y[j]]) for j in range(len(y))]\n",
    "            ax[i].set_xlim(0)\n",
    "\n",
    "        ax[i].set_ylim(0, 1)\n",
    "        ax[i].set_xlabel(xlabel)\n",
    "        ax[i].set_ylabel(ylabel[i])\n",
    "\n",
    "        if legend is not None:\n",
    "            ax[i].legend(legend, fontsize=legendsize)\n",
    "\n",
    "    plt.tight_layout()\n",
    "\n",
    "    return fig, ax"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "fdafa289-98b4-4138-8eef-a653ff7c4428",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
