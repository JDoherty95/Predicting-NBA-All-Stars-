{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 8,
   "id": "64223174-692b-4884-89a0-a849996c7525",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'nbapredict'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "\u001b[0;32m/var/folders/pb/9nrds4y576x41j1jw01gnkc40000gn/T/ipykernel_5343/2287896755.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m     17\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     18\u001b[0m \u001b[0;31m# Local imports\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m---> 19\u001b[0;31m \u001b[0;32mfrom\u001b[0m \u001b[0mnbapredict\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mconfiguration\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mConfig\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m     20\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mnbapredict\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhelpers\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mbr_references\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m     21\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mdatatotable\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdatabase\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mDatabase\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'nbapredict'"
     ]
    }
   ],
   "source": [
    "\"\"\"\n",
    "Predict.odds contains functions organized around comparing predictions to odds\n",
    "ToDo:\n",
    "    In theory, the module will allow multiple model inputs. Thus, we can pass it a linear, bayesian, ML, etc. model,\n",
    "    generate results, and store them. That functionality does not exist. This should also have a class of some sort to\n",
    "    manage predictions. It will add specificity and remove call complexity and name overlaps (i.e.\n",
    "    predict_games_on_day() vs. predict_games_on_date())\n",
    "\"\"\"\n",
    "\n",
    "from datetime import datetime\n",
    "import numpy as np\n",
    "import pandas as pd\n",
    "import scipy.stats as stats\n",
    "from sqlalchemy.orm import Session\n",
    "from sqlalchemy import or_\n",
    "from sqlalchemy.exc import IntegrityError\n",
    "\n",
    "# Local imports\n",
    "from nbapredict.configuration import Config\n",
    "from nbapredict.helpers import br_references\n",
    "from datatotable.database import Database\n",
    "from datatotable.data import DataOperator\n",
    "from nbapredict.database import getters\n",
    "from nbapredict.management import conversion\n",
    "from nbapredict.management.tables import predictions\n",
    "from nbapredict.models import four_factor_regression as ff_reg\n",
    "\n",
    "\n",
    "def get_prediction(reg, pred_df):\n",
    "    \"\"\"Generate and return a prediction for the observations in the pred_df.\n",
    "    Args:\n",
    "        reg: LinearRegression class from four_factors_regression.py\n",
    "        pred_df: A dataframe of observations, with home and away statistics, from which to generate a prediction\n",
    "    Returns:\n",
    "        The predicted value generated from the regression object and the predictors\"\"\"\n",
    "    return reg.results.predict(pred_df).values[0]\n",
    "\n",
    "\n",
    "def get_team_name(team):\n",
    "    \"\"\"Match team to a standard team name and return the br_references standard team name.\"\"\"\n",
    "    for team_name in br_references.Team:\n",
    "        if team.lower() == team_name.value.lower():\n",
    "            return team_name.value\n",
    "\n",
    "\n",
    "# def create_prediction_df(home_tm, away_tm, ff_df):\n",
    "#     \"\"\"Create and return a dataframe that merges the four factors for the home and away team.\n",
    "#     TODO: Replace with ff_reg.alt_regression_df/getregression_df\n",
    "#\n",
    "#     Args:\n",
    "#         home_tm: The home team\n",
    "#         away_tm: The away team\n",
    "#         ff_df: Dataframe of the four factors for all teams\n",
    "#\n",
    "#     Returns:\n",
    "#         A single row four factors data frame of the home and away team's four factors\n",
    "#     \"\"\"\n",
    "#     home_ff = get_team_ff(home_tm, ff_df, home=True)\n",
    "#     away_ff = get_team_ff(away_tm, ff_df, home=False)\n",
    "#     home_ff[\"key\"] = 1\n",
    "#     home_ff[\"const\"] = 1.0  # sm.add_const does not add a constant for whatever reason\n",
    "#     away_ff[\"key\"] = 1\n",
    "#     merged = pd.merge(home_ff, away_ff, on=\"key\", sort=True)\n",
    "#     merged = merged.drop([\"key\"], axis=1)\n",
    "#     merged = merged.sort_index(axis=1)\n",
    "#     return merged\n",
    "\n",
    "\n",
    "def get_team_ff(team, ff_df, home):\n",
    "    \"\"\"Create and return a data frame of the four factors for the specified team.\n",
    "    Args:\n",
    "        team: The team to extract the four factors for\n",
    "        ff_df: A dataframe of the four factors\n",
    "        home: Boolean which dictates if an '_h or '_a' should be appended to the team's stats\n",
    "    Returns:\n",
    "        The four factors, with a home or away suffix, for a team are returned as a data frame\n",
    "    \"\"\"\n",
    "    ff_list = br_references.four_factors\n",
    "    team_ff = ff_df[ff_df.team_name.str.lower() == team.lower()][ff_list]\n",
    "    if home:\n",
    "        team_ff = team_ff.rename(ff_reg.append_h, axis='columns')\n",
    "    else:\n",
    "        team_ff = team_ff.rename(ff_reg.append_a, axis='columns')\n",
    "    return team_ff\n",
    "\n",
    "\n",
    "def line_probability(prediction, line, std):\n",
    "    \"\"\"Calculate and return the CDF or SF, as appropriate, of the line if the model were true.\n",
    "    \"if the model were true\" means that if the assumption holds that the residuals are homoscedastic and follow a\n",
    "    normal distribution\n",
    "    Args:\n",
    "        prediction: The prediction for a game\n",
    "        line: The line associated with the same game as the prediction\n",
    "        std: The standard deviation of the residuals for the model used to make the prediction\n",
    "    Returns:\n",
    "        The survival function or cumulative density function for the line in relation to the prediction\n",
    "    \"\"\"\n",
    "    # ToDo: T-Distribution?\n",
    "    dist = stats.norm(loc=prediction, scale=std)\n",
    "    line_prediction = -1 * line\n",
    "\n",
    "    if prediction > line_prediction:\n",
    "        return dist.cdf(line_prediction), \"cdf\"\n",
    "    elif prediction < line_prediction:\n",
    "        return dist.sf(line_prediction), \"sf\"\n",
    "    elif prediction == line_prediction:\n",
    "        return 0.5  # If the predictions are equal, the cdf automatically equals 0.5\n",
    "\n",
    "\n",
    "def prediction_result_console_output(home_tm, away_tm, line, prediction, probability):\n",
    "    \"\"\"Generate human readable printout comparing the model's predictions, the line, and the p_value of the line.\n",
    "    Args:\n",
    "        home_tm: The home team\n",
    "        away_tm: The away team\n",
    "        line: The betting line\n",
    "        prediction: A prediction of the home team's margin of victory\n",
    "        probability: The probability of the betting line as determined by a CDF or SF\n",
    "    \"\"\"\n",
    "    if prediction > 0:\n",
    "        print(\"The {} are projected to beat the {} by {} points\".format(home_tm, away_tm, prediction))\n",
    "        if (-1 * line) < prediction:\n",
    "            print(\"If the model were true, the betting line's ({}) CDF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "        else:\n",
    "            print(\"If the model were true, the betting line's ({}) SF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "    if prediction < 0:\n",
    "        print(\"The {} are projected to lose to the {} by {} points\".format(home_tm, away_tm, prediction))\n",
    "        if (-1 * line) < prediction:\n",
    "            print(\"If the model were true, the betting line's ({}) CDF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "        else:\n",
    "            print(\"If the model were true, the betting line's ({}) SF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "\n",
    "\n",
    "def insert_predictions(rows, session, pred_tbl, sched_tbl):\n",
    "    \"\"\"Add rows into the prediction table in session with additional information from sched_tbl and odds_tbl.\n",
    "    # ToDo: Will need equivalent function, but it won't look like this\n",
    "    Args:\n",
    "        rows: SQLalchemy compatible rows\n",
    "        session: A SQLalchemy session object\n",
    "        pred_tbl: A mapped prediction table object\n",
    "        sched_tbl: A mapped scheduled table object\n",
    "    \"\"\"\n",
    "    row_objects = []\n",
    "    for row in rows:\n",
    "        row_obj = pred_tbl(**row)\n",
    "        row_objects.append(row_obj)\n",
    "    row_objects = update_schedule_attributes(row_objects, session, sched_tbl)\n",
    "\n",
    "    session.add_all(row_objects)\n",
    "\n",
    "\n",
    "def insert_new_predictions(rows, session, pred_tbl, sched_tbl, odds_tbl):\n",
    "    \"\"\"Insert unique predictions in rows which do not already exist in the prediction table.\n",
    "    Additional information from sched_tbl and odds_tbl is added to the rows as well.\n",
    "    # ToDo: Will need significant rewrite (Also note similarities between this function and the one above)\n",
    "    Args:\n",
    "        rows: SQLalchemy compatible rows\n",
    "        session: a SQLalchemy session object\n",
    "        pred_tbl: A mapped prediction table object\n",
    "        sched_tbl: A mapped scheduled table object\n",
    "        odds_tbl: A mapped odds_tbl object\n",
    "    \"\"\"\n",
    "    row_objects = []\n",
    "    existing_predictions = session.query(pred_tbl.home_team, pred_tbl.away_team, pred_tbl.start_time).all()\n",
    "    existing_predictions = [(game.home_team, game.away_team, game.start_time) for game in existing_predictions]\n",
    "    for row in rows:\n",
    "        game_identifier = (row[\"home_team\"], row[\"away_team\"], row[\"start_time\"])\n",
    "        if game_identifier in existing_predictions:\n",
    "            continue\n",
    "        else:\n",
    "            row_obj = pred_tbl(**row)\n",
    "            row_objects.append(row_obj)\n",
    "    if len(row_objects) > 0:\n",
    "        row_objects = update_odds_id(row_objects, session, odds_tbl)\n",
    "        row_objects = update_schedule_attributes(row_objects, session, sched_tbl)\n",
    "        session.add_all(row_objects)\n",
    "\n",
    "\n",
    "def update_prediction_table(session, pred_tbl, sched_tbl, odds_tbl):\n",
    "    \"\"\"Find and update null or 0 values in the score, odds_id, or bet_result columns of the prediction table.\n",
    "    Args:\n",
    "        session: A SQLalchemy session object\n",
    "        pred_tbl: A mapped prediction table object\n",
    "        sched_tbl: A mapped scheduled table object\n",
    "        odds_tbl: A mapped odds_tbl object\n",
    "    \"\"\"\n",
    "    score_update_objs = session.query(pred_tbl).filter(or_(pred_tbl.home_team_score == 0,\n",
    "                                                           pred_tbl.away_team_score == 0)).all()\n",
    "    session.add_all(score_update_objs)\n",
    "\n",
    "    bet_update_objs = session.query(pred_tbl).filter(pred_tbl.bet_result.is_(None), pred_tbl.home_team_score > 0).all()\n",
    "    bet_update_objs = update_bet_results(bet_update_objs)\n",
    "    session.add_all(bet_update_objs)\n",
    "\n",
    "\n",
    "def update_bet_results(bet_update_objects):\n",
    "    \"\"\"Take bet_update_objects, determine the prediction result, and add the result to each row in bet_update_objects.\n",
    "    # ToDo: Will need this function, but will require a lot of modification\n",
    "    Args:\n",
    "        bet_update_objects: Objects from a query.all() from the prediction table. Objects should have a home and\n",
    "        away team score.\n",
    "    Returns:\n",
    "        bet_update_objects updated with the bet results (WIN, LOSS, or PUSH).\n",
    "    \"\"\"\n",
    "    for row in bet_update_objects:\n",
    "        score_margin = row.home_team_score - row.away_team_score\n",
    "        line_inverse = row.line * -1\n",
    "        prediction = row.prediction\n",
    "        if score_margin == line_inverse:\n",
    "            row.bet_result = \"PUSH\"\n",
    "        elif (score_margin < line_inverse) and (prediction < line_inverse):\n",
    "            row.bet_result = \"WIN\"\n",
    "        elif (score_margin > line_inverse) and (prediction > line_inverse):\n",
    "            row.bet_result = \"WIN\"\n",
    "        else:\n",
    "            row.bet_result = \"LOSS\"\n",
    "    return bet_update_objects\n",
    "\n",
    "\n",
    "def get_sample_prediction(session, regression):\n",
    "    \"\"\"Generate and return a sample prediction formatted specifically for table creation.\n",
    "    Args:\n",
    "        session: A SQLalchemy session object\n",
    "        regression: A regression object from four_factor_regression.py\n",
    "    Returns:\n",
    "        A DataOperator object initialized with a prediction from regression\n",
    "    \"\"\"\n",
    "    one_row_dataframe = regression.predictors.loc[[0]]\n",
    "\n",
    "    sample_prediction = predict_game(session, regression, one_row_dataframe)\n",
    "    data = DataOperator(sample_prediction)\n",
    "    return data\n",
    "\n",
    "\n",
    "def predict_game(session, regression, x_df, console_out=False):\n",
    "    \"\"\"Predict a game and return the information in a dictionary.\n",
    "    Use console out for human readable output if desired.Cdf is a cumulative density function. SF is a survival\n",
    "    function. CDF is calculated when the betting line's prediction is below the model's prediction. SF is calculated\n",
    "    when the betting line's prediction is above the model's prediction.\n",
    "    Args:\n",
    "        session: A SQLalchemy session object\n",
    "        regression: A regression object\n",
    "        console_out: If true, print the prediction results. Ignore otherwise\n",
    "    \"\"\"\n",
    "\n",
    "    prediction = get_prediction(regression, x_df)\n",
    "    # probability, function = line_probability(prediction, line, np.std(regression.residuals))\n",
    "\n",
    "    # if console_out:\n",
    "    #     prediction_result_console_output(home_tm, away_tm, prediction, probability)\n",
    "\n",
    "    return {\"prediction\": prediction}\n",
    "\n",
    "\n",
    "def predict_games_in_odds(session, regression, odds_tbl):\n",
    "    \"\"\"Generate and return predictions for all games with odds in the odds_tbl\n",
    "    ToDo: Take tables as inputs vs. DB\n",
    "    Args:\n",
    "        session: A SQLalchemy session object\n",
    "        regression: A linear regression object generated from four_factor_regression\n",
    "        odds_tbl: Mapped sqlalchemy odds table\n",
    "    \"\"\"\n",
    "    all_odds = session.query(odds_tbl).all()\n",
    "    predictions = []\n",
    "    for odds in all_odds:\n",
    "        home_team = odds.home_team\n",
    "        away_team = odds.away_team\n",
    "        start_time = odds.start_time\n",
    "        line = odds.spread\n",
    "        predictions.append(predict_game(session, regression, home_team, away_team, start_time, line))\n",
    "    return predictions\n",
    "\n",
    "\n",
    "def predict_games_on_day(database, session, games, console_out=False):\n",
    "    \"\"\"Take a SQLalchemy query object of games, and return a prediction for each game.\n",
    "    ToDO: On day versus on date?\n",
    "    Args:\n",
    "        database: an instantiated DBInterface class from database.dbinterface.py\n",
    "        session: A SQLalchemy session object\n",
    "        games: a SQLalchemy query object of games containing start_time, home_tm, away_tm, and the spread\n",
    "        console_out: A bool. True to print prediction outputs\n",
    "    \"\"\"\n",
    "    results = []\n",
    "    regression = ff_reg.main(database=database, session=session, year=year)\n",
    "    try:\n",
    "        for game in games:\n",
    "            prediction = predict_game(database=database, session=session, regression=regression, home_tm=game.home_team,\n",
    "                                      away_tm=game.away_team, start_time=game.start_time, line=game.spread,\n",
    "                                      console_out=console_out)\n",
    "            results.append(prediction)\n",
    "    except AttributeError:\n",
    "        # If games doesn't contain spreads, catch the attribute error and pass a 0 line.\n",
    "        # If games is missing other data, function will break.\n",
    "        for game in games:\n",
    "            prediction = predict_game(database=database, session=session, regression=regression, home_tm=game.home_team,\n",
    "                                      away_tm=game.away_team, start_time=game.start_time, line=0,\n",
    "                                      console_out=console_out)\n",
    "            results.append(prediction)\n",
    "    return results\n",
    "\n",
    "\n",
    "def predict_games_on_date(database, session, league_year, date, console_out):\n",
    "    \"\"\"Predict games on the specified date and write the results to the database\n",
    "    ToDO: On day versus on date?\n",
    "    Args:\n",
    "        database: An instantiated DBInterface class from dbinterface.py\n",
    "        session: A sqlalchemy session object for queries and writes\n",
    "        league_year: The league year to work with. For example, the league year of the 2018-19 season is 2019\n",
    "        date: Either a datetime.date or a dictionary keyed formatted as {\"day\": day, \"month\": month, \"year\": year\"}\n",
    "        console_out: If true, prints prediction results to the console\n",
    "    \"\"\"\n",
    "    # Get lines for the games\n",
    "    if not isinstance(date, datetime):\n",
    "        date = datetime(date[\"year\"], date[\"month\"], date[\"day\"])\n",
    "    odds_tbl = database.get_table_mappings([\"odds_{}\".format(league_year)])\n",
    "    games_query = getters.get_spreads_for_date(odds_tbl, session, date)\n",
    "    game_spreads = [game for game in games_query]\n",
    "\n",
    "    results = predict_games_on_day(database, session, game_spreads, console_out=console_out)\n",
    "\n",
    "    prediction_tbl = \"predictions_{}\".format(league_year)\n",
    "    data = DataOperator(results)\n",
    "\n",
    "    sched_tbl = database.get_table_mappings(\"sched_{}\".format(league_year))\n",
    "    pred_tbl = database.get_table_mappings(\"predictions_{}\".format(league_year))\n",
    "\n",
    "    # Results are sent to DataOperator in row format, so just pass data.data instead of data.dict_to_rows()\n",
    "    try:\n",
    "        insert_predictions(data.data, session, pred_tbl, sched_tbl, odds_tbl)\n",
    "        session.commit()\n",
    "    except IntegrityError:\n",
    "        session.rollback()\n",
    "        update_prediction_table(session, pred_tbl, sched_tbl, odds_tbl)\n",
    "        session.commit()\n",
    "    finally:\n",
    "        session.close()\n",
    "\n",
    "\n",
    "def predict_all(db):\n",
    "    \"\"\"Generate and store predictions for all games available in the odds table.\n",
    "    Checks if the table exists. If it doesn't, generate a table in the database.\n",
    "    \"\"\"\n",
    "    session = Session(bind=db.engine)\n",
    "    league_year = Config.get_property(\"league_year\")\n",
    "    sched_tbl = db.table_mappings[\"schedule_{}\".format(league_year)]\n",
    "    team_stats_tbl = db.table_mappings['team_stats_{}'.format(league_year)]\n",
    "    odds_tbl = db.table_mappings['odds_{}'.format(league_year)]\n",
    "\n",
    "    regression = ff_reg.main(session, team_stats_tbl, sched_tbl)\n",
    "\n",
    "    pred_tbl_name = \"predictions_{}\".format(league_year)\n",
    "\n",
    "    if not db.table_exists(pred_tbl_name):\n",
    "        sample = get_sample_prediction(session, regression, sched_tbl)\n",
    "        pred_data = predictions.format_data()\n",
    "        predictions.create_table()\n",
    "        pred_tbl = db.table_mappings[pred_tbl_name]\n",
    "        session.add_all([pred_tbl(**row) for row in pred_data.rows])\n",
    "        session.commit()\n",
    "    else:\n",
    "        # Data operator\n",
    "        pred_tbl = db.table_mappings[pred_tbl_name]\n",
    "        schedule_tbl = db.table_mappings[pred_tbl_name]\n",
    "        update_rows = predictions.insert(session, )\n",
    "        results = predict_games_in_odds(session, regression, odds_tbl)\n",
    "        session.add_all(update_rows)\n",
    "        session.commit()\n",
    "\n",
    "    insert_new_predictions(results, session, pred_tbl, sched_tbl, odds_tbl)\n",
    "\n",
    "    session.commit()  # Commit here b/c update_prediction_tbl() needs the inserted values\n",
    "\n",
    "    update_prediction_table(session, pred_tbl, sched_tbl, odds_tbl)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    db = Database('test', \"../management\")\n",
    "    predict_all(db)\n",
    "    predict_game(\"Sacramento Kings\", \"Orlando Magic\", line=-5.5, year=2019, console_out=True)\n",
    "    date = datetime(2019, 3, 26)\n",
    "    predict_games_on_date(db, session, league_year=2019, date=date, console_out=True)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f25f8ba9-38cb-441e-b77f-02cf78e3c7ad",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "c4d9afef-737a-467e-b9f5-88e14c0feb35",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
