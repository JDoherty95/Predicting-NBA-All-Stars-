{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "8c6a95ff-4452-40d4-8ac6-216b54e20b38",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'nbapredict'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mModuleNotFoundError\u001b[0m                       Traceback (most recent call last)",
      "\u001b[0;32m/var/folders/pb/9nrds4y576x41j1jw01gnkc40000gn/T/ipykernel_8235/1690322892.py\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[1;32m      2\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mpandas\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mpd\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0;32m----> 4\u001b[0;31m \u001b[0;32mimport\u001b[0m \u001b[0mnbapredict\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmodels\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mfour_factor_regression\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mlm\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      5\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mnbapredict\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mhelpers\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mbr_references\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mbr_references\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      6\u001b[0m \u001b[0;32mfrom\u001b[0m \u001b[0mnbapredict\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mdatabase\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0mmanipulator\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mDataOperator\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'nbapredict'"
     ]
    }
   ],
   "source": [
    "\"\"\"Funcs contains functions for generating predictions and their helper functions.\"\"\"\n",
    "import pandas as pd\n",
    "\n",
    "import nbapredict.models.four_factor_regression as lm\n",
    "import nbapredict.helpers.br_references as br_references\n",
    "from nbapredict.database.manipulator import DataOperator\n",
    "import nbapredict.database.getters as getters\n",
    "\n",
    "\n",
    "def sample_prediction(database, session, ref_tbl, model):\n",
    "    \"\"\"Generate and return a one row sample prediction created from the first row of the reference table.\n",
    "    ToDo: Change function to take any model\n",
    "    ToDo: Change docstring to reference new classes, perhaps drop DB arg\n",
    "    Args:\n",
    "        database: An initialized DBInterface class from database.dbinterface.py\n",
    "        session: A SQLalchemy session object\n",
    "        ref_tbl: A mapped odds table\n",
    "        model: A regression object from four_factor_regression.py\n",
    "    Returns:\n",
    "        A DataOperator object initialized with a prediction from regression\n",
    "    \"\"\"\n",
    "    first_game_odds = session.query(ref_tbl).order_by(ref_tbl.start_time).first()\n",
    "\n",
    "    home_tm = first_game_odds.home_team\n",
    "    away_tm = first_game_odds.away_team\n",
    "    start_time = first_game_odds.start_time\n",
    "\n",
    "    sample_prediction = game_prediction(database, session, model, home_tm, away_tm, start_time)\n",
    "    data = DataOperator(sample_prediction)\n",
    "    return data\n",
    "\n",
    "\n",
    "def game_prediction(database, session, regression, home_tm, away_tm, start_time, year=2019, console_out=False):\n",
    "    \"\"\"Predict a game versus the line, and return the information in a dictionary.\n",
    "    Use console out for human readable output if desired. Cdf is a cumulative density function. SF is a survival\n",
    "    function. CDF is calculated when the betting line's prediction is below the model's prediction. SF is calculated\n",
    "    when the betting line's prediction is above the model's prediction.\n",
    "    ToDO: Modify to use new database\n",
    "    Args:\n",
    "        database: an instantiated DBInterface class from database.dbinterface.py\n",
    "        session: A SQLalchemy session object\n",
    "        regression: A regression object\n",
    "        start_time: Date.datetime with the date and start time of the game\n",
    "        home_tm: The home team\n",
    "        away_tm: The away team\n",
    "        line: The betting line\n",
    "        year: The year to use stats from in predicting the game\n",
    "        console_out: If true, print the prediction results. Ignore otherwise\n",
    "    \"\"\"\n",
    "    home_tm = team_name(home_tm)\n",
    "    away_tm = team_name(away_tm)\n",
    "\n",
    "    # Get Misc stats for year\n",
    "    ff_list = lm.four_factors_list()\n",
    "    ff_df = getters.get_pandas_df_from_table(database, session, \"misc_stats_{}\".format(year), ff_list)\n",
    "\n",
    "    pred_df = prediction_df(home_tm, away_tm, ff_df)\n",
    "    pred = prediction(regression, pred_df)\n",
    "    # probability, function = line_probability(prediction, line, np.std(regression.residuals))\n",
    "\n",
    "    #if console_out:\n",
    "    #    prediction_result_console_output(home_tm, away_tm, line, prediction, probability)\n",
    "\n",
    "    return {\"start_time\": start_time, \"home_team\": home_tm, \"away_team\": away_tm, \"prediction\": pred}\n",
    "\n",
    "\n",
    "def prediction(reg, pred_df):\n",
    "    \"\"\"Generate and return a prediction for the observations in the pred_df.\n",
    "    Args:\n",
    "        reg: LinearRegression class from four_factors_regression.py\n",
    "        pred_df: A dataframe of observations, with home and away statistics, from which to generate a prediction\n",
    "    Returns:\n",
    "        The predicted value generated from the regression object and the predictors\"\"\"\n",
    "    return reg.results.predict(pred_df).values[0]\n",
    "\n",
    "\n",
    "def console_output(home_tm, away_tm, line, prediction, probability):\n",
    "    \"\"\"Generate human readable printout comparing the model's predictions, the line, and the p_value of the line.\n",
    "    Args:\n",
    "        home_tm: The home team\n",
    "        away_tm: The away team\n",
    "        line: The betting line\n",
    "        prediction: A prediction of the home team's margin of victory\n",
    "        probability: The probability of the betting line as determined by a CDF or SF\n",
    "    \"\"\"\n",
    "    if prediction > 0:\n",
    "        print(\"The {} are projected to beat the {} by {} points\".format(home_tm, away_tm, prediction))\n",
    "        if (-1 * line) < prediction:\n",
    "            print(\"If the model were true, the betting line's ({}) CDF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "        else:\n",
    "            print(\"If the model were true, the betting line's ({}) SF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "    if prediction < 0:\n",
    "        print(\"The {} are projected to lose to the {} by {} points\".format(home_tm, away_tm, prediction))\n",
    "        if (-1 * line) < prediction:\n",
    "            print(\"If the model were true, the betting line's ({}) CDF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "        else:\n",
    "            print(\"If the model were true, the betting line's ({}) SF, in relation to the prediction, would \"\n",
    "                  \"be realized {}% of the time\".format(line, probability))\n",
    "\n",
    "\n",
    "def prediction_df(home_tm, away_tm, ff_df):\n",
    "    \"\"\"Create and return a dataframe that merges the four factors for the home and away team.\n",
    "    Args:\n",
    "        home_tm: The home team\n",
    "        away_tm: The away team\n",
    "        ff_df: Dataframe of the four factors for all teams\n",
    "    Returns:\n",
    "        A single row four factors data frame of the home and away team's four factors\n",
    "    \"\"\"\n",
    "    home_ff = team_ff(home_tm, ff_df, home=True)\n",
    "    away_ff = team_ff(away_tm, ff_df, home=False)\n",
    "    home_ff[\"key\"] = 1\n",
    "    home_ff[\"const\"] = 1.0  # sm.add_const does not add a constant for whatever reason\n",
    "    away_ff[\"key\"] = 1\n",
    "    merged = pd.merge(home_ff, away_ff, on=\"key\", sort=True)\n",
    "    merged = merged.drop([\"key\"], axis=1)\n",
    "    merged = merged.sort_index(axis=1)\n",
    "    return merged\n",
    "\n",
    "\n",
    "def team_ff(team, ff_df, home):\n",
    "    \"\"\"Create and return a data frame of the four factors for the specified team.\n",
    "    Args:\n",
    "        team: The team to extract the four factors for\n",
    "        ff_df: A dataframe of the four factors\n",
    "        home: Boolean which dictates if an '_h or '_a' should be appended to the team's stats\n",
    "    Returns:\n",
    "        The four factors, with a home or away suffix, for a team are returned as a data frame\n",
    "    \"\"\"\n",
    "    ff_list = br_references.four_factors\n",
    "    team_ff = ff_df[ff_df.team_name.str.lower() == team.lower()][ff_list]\n",
    "    if home:\n",
    "        team_ff = team_ff.rename(lm.append_h, axis='columns')\n",
    "    else:\n",
    "        team_ff = team_ff.rename(lm.append_a, axis='columns')\n",
    "    return team_ff\n",
    "\n",
    "\n",
    "def team_name(team):\n",
    "    \"\"\"Match team to a standard team name (not cap-sensitive) and return the br_references standard team name.\"\"\"\n",
    "    for team_name in br_references.Team:\n",
    "        if team.lower() == team_name.value.lower():\n",
    "            return team_name.value"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "f78104a7-7a7b-4890-85fe-4a5c1f42e9aa",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.2"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
